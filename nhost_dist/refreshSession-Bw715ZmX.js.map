{"version":3,"file":"refreshSession-Bw715ZmX.js","sources":["../src/session/refreshSession.ts"],"sourcesContent":["import type { Client as AuthClient, ErrorResponse } from \"../auth\";\nimport type { FetchResponse } from \"../fetch\";\nimport type { Session } from \"./session\";\nimport type { SessionStorage } from \"./storage\";\n\nclass DummyLock implements Lock {\n  async request(\n    _name: string,\n    _options: { mode: \"exclusive\" | \"shared\" },\n    // biome-ignore lint/suspicious/noExplicitAny: any\n    callback: () => Promise<any>,\n  ) {\n    return callback();\n  }\n}\n\ninterface Lock {\n  request: (\n    name: string,\n    options: { mode: \"exclusive\" | \"shared\" },\n    // biome-ignore lint/suspicious/noExplicitAny: blah\n    callback: () => Promise<any>,\n    // biome-ignore lint/suspicious/noExplicitAny: blah\n  ) => Promise<any>;\n}\n\nconst lock: Lock =\n  typeof navigator !== \"undefined\" && navigator.locks\n    ? navigator.locks\n    : new DummyLock();\n\n/**\n * Refreshes the authentication session if needed\n *\n * This function checks if the current session needs to be refreshed based on\n * the access token expiration time. If a refresh is needed, it will attempt to\n * refresh the token using the provided auth client.\n *\n * @param auth - The authentication client to use for token refresh\n * @param storage - The session storage implementation\n * @param marginSeconds - The number of seconds before the token expiration to refresh the session. If the token is still valid for this duration, it will not be refreshed. Set to 0 to force the refresh.\n * @returns A promise that resolves to the current session (refreshed if needed) or null if no session exists\n */\nexport const refreshSession = async (\n  auth: AuthClient,\n  storage: SessionStorage,\n  marginSeconds = 60,\n): Promise<Session | null> => {\n  try {\n    return await _refreshSession(auth, storage, marginSeconds);\n  } catch (error) {\n    try {\n      // we retry the refresh token in case of transient error\n      // or race conditions\n      console.warn(\"error refreshing session, retrying:\", error);\n      return await _refreshSession(auth, storage, marginSeconds);\n    } catch (error) {\n      const errResponse = error as FetchResponse<ErrorResponse>;\n      if (errResponse?.status === 401) {\n        // this probably means the refresh token is invalid\n        console.error(\"session probably expired\");\n        storage.remove();\n      }\n      return null;\n    }\n  }\n};\n\n/**\n * Internal implementation of the refresh session logic\n *\n * @param auth - The authentication client to use for token refresh\n * @param storage - The session storage implementation\n * @param marginSeconds - How many seconds before expiration to trigger a refresh\n * @returns A promise that resolves to the current session (refreshed if needed) or null if no session exists\n * @private\n */\nconst _refreshSession = async (\n  auth: AuthClient,\n  storage: SessionStorage,\n  marginSeconds = 60,\n): Promise<Session | null> => {\n  const {\n    session,\n    needsRefresh,\n  }: { session: Session | null; needsRefresh: boolean } = await lock.request(\n    \"nhostSessionLock\",\n    { mode: \"shared\" },\n    async () => {\n      return _needsRefresh(storage, marginSeconds);\n    },\n  );\n\n  if (!session) {\n    return null; // No session found\n  }\n\n  if (!needsRefresh) {\n    return session; // No need to refresh\n  }\n\n  const refreshedSession: Session | null = await lock.request(\n    \"nhostSessionLock\",\n    { mode: \"exclusive\" },\n    async () => {\n      const { session, needsRefresh, sessionExpired } = _needsRefresh(\n        storage,\n        marginSeconds,\n      );\n\n      if (!session) {\n        return null; // No session found\n      }\n\n      if (!needsRefresh) {\n        return session; // No need to refresh\n      }\n\n      try {\n        const response = await auth.refreshToken({\n          refreshToken: session.refreshToken,\n        });\n        storage.set(response.body);\n\n        return response.body;\n      } catch (error) {\n        if (!sessionExpired) {\n          return session;\n        }\n\n        throw error;\n      }\n    },\n  );\n\n  return refreshedSession;\n};\n\n/**\n * Checks if the current session needs to be refreshed based on token expiration\n *\n * @param storage - The session storage implementation\n * @param marginSeconds - How many seconds before expiration to trigger a refresh\n * @returns An object containing the session, whether it needs refreshing, and whether it has expired\n * @private\n */\nconst _needsRefresh = (storage: SessionStorage, marginSeconds = 60) => {\n  const session = storage.get();\n  if (!session) {\n    return { session: null, needsRefresh: false, sessionExpired: false };\n  }\n\n  if (!session.decodedToken || !session.decodedToken.exp) {\n    // if the session does not have a valid decoded token, treat it as expired\n    // as we can't determine its validity\n    return { session, needsRefresh: true, sessionExpired: true };\n  }\n\n  // Force refresh if marginSeconds is 0\n  if (marginSeconds === 0) {\n    return { session, needsRefresh: true, sessionExpired: false };\n  }\n\n  const currentTime = Date.now();\n  if (session.decodedToken.exp - currentTime > marginSeconds * 1000) {\n    return { session, needsRefresh: false, sessionExpired: false };\n  }\n\n  return {\n    session,\n    needsRefresh: true,\n    sessionExpired: session.decodedToken.exp < currentTime,\n  };\n};\n"],"names":["lock","navigator","locks","request","_name","_options","callback","_refreshSession","async","auth","storage","marginSeconds","session","needsRefresh","mode","_needsRefresh","sessionExpired","response","refreshToken","set","body","error","get","decodedToken","exp","currentTime","Date","now","console","warn","errResponse","status","remove"],"mappings":"aA0BA,MAAMA,EACiB,oBAAdC,WAA6BA,UAAUC,MAC1CD,UAAUC,MACV,IAxBN,MACE,aAAMC,CACJC,EACAC,EAEAC,GAEA,OAAOA,GACT,GAgEIC,EAAkBC,MACtBC,EACAC,EACAC,EAAgB,MAEhB,MAAMC,QACJA,EAAAC,aACAA,SAC4Db,EAAKG,QACjE,mBACA,CAAEW,KAAM,WACRN,SACSO,EAAcL,EAASC,KAIlC,IAAKC,EACH,OAAO,KAGT,IAAKC,EACH,OAAOD,EAqCT,aAlC+CZ,EAAKG,QAClD,mBACA,CAAEW,KAAM,cACRN,UACE,MAAQI,QAAAA,EAASC,aAAAA,EAAAA,eAAcG,GAAmBD,EAChDL,EACAC,GAGF,IAAKC,EACH,OAAO,KAGT,IAAKC,EACH,OAAOD,EAGT,IACE,MAAMK,QAAiBR,EAAKS,aAAa,CACvCA,aAAcN,EAAQM,eAIxB,OAFAR,EAAQS,IAAIF,EAASG,MAEdH,EAASG,IAClB,OAASC,GACP,IAAKL,EACH,OAAOJ,EAGT,MAAMS,CACR,IAIG,EAWHN,EAAgB,CAACL,EAAyBC,EAAgB,MAC9D,MAAMC,EAAUF,EAAQY,MACxB,IAAKV,EACH,MAAO,CAAEA,QAAS,KAAMC,cAAc,EAAOG,gBAAgB,GAG/D,IAAKJ,EAAQW,eAAiBX,EAAQW,aAAaC,IAGjD,MAAO,CAAEZ,UAASC,cAAc,EAAMG,gBAAgB,GAIxD,GAAsB,IAAlBL,EACF,MAAO,CAAEC,UAASC,cAAc,EAAMG,gBAAgB,GAGxD,MAAMS,EAAcC,KAAKC,MACzB,OAAIf,EAAQW,aAAaC,IAAMC,EAA8B,IAAhBd,EACpC,CAAEC,UAASC,cAAc,EAAOG,gBAAgB,GAGlD,CACLJ,UACAC,cAAc,EACdG,eAAgBJ,EAAQW,aAAaC,IAAMC,EAAA,yBAhIjBjB,MAC5BC,EACAC,EACAC,EAAgB,MAEhB,IACE,aAAaJ,EAAgBE,EAAMC,EAASC,EAC9C,OAASU,GACP,IAIE,OADAO,QAAQC,KAAK,sCAAuCR,SACvCd,EAAgBE,EAAMC,EAASC,EAC9C,OAASU,GACP,MAAMS,EAAcT,EAMpB,OAL4B,MAAxBS,GAAaC,SAEfH,QAAQP,MAAM,4BACdX,EAAQsB,UAEH,IACT,CACF"}
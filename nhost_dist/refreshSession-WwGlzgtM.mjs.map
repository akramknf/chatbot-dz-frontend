{"version":3,"file":"refreshSession-WwGlzgtM.mjs","sources":["../src/session/refreshSession.ts"],"sourcesContent":["import type { Client as AuthClient, ErrorResponse } from \"../auth\";\nimport type { FetchResponse } from \"../fetch\";\nimport type { Session } from \"./session\";\nimport type { SessionStorage } from \"./storage\";\n\nclass DummyLock implements Lock {\n  async request(\n    _name: string,\n    _options: { mode: \"exclusive\" | \"shared\" },\n    // biome-ignore lint/suspicious/noExplicitAny: any\n    callback: () => Promise<any>,\n  ) {\n    return callback();\n  }\n}\n\ninterface Lock {\n  request: (\n    name: string,\n    options: { mode: \"exclusive\" | \"shared\" },\n    // biome-ignore lint/suspicious/noExplicitAny: blah\n    callback: () => Promise<any>,\n    // biome-ignore lint/suspicious/noExplicitAny: blah\n  ) => Promise<any>;\n}\n\nconst lock: Lock =\n  typeof navigator !== \"undefined\" && navigator.locks\n    ? navigator.locks\n    : new DummyLock();\n\n/**\n * Refreshes the authentication session if needed\n *\n * This function checks if the current session needs to be refreshed based on\n * the access token expiration time. If a refresh is needed, it will attempt to\n * refresh the token using the provided auth client.\n *\n * @param auth - The authentication client to use for token refresh\n * @param storage - The session storage implementation\n * @param marginSeconds - The number of seconds before the token expiration to refresh the session. If the token is still valid for this duration, it will not be refreshed. Set to 0 to force the refresh.\n * @returns A promise that resolves to the current session (refreshed if needed) or null if no session exists\n */\nexport const refreshSession = async (\n  auth: AuthClient,\n  storage: SessionStorage,\n  marginSeconds = 60,\n): Promise<Session | null> => {\n  try {\n    return await _refreshSession(auth, storage, marginSeconds);\n  } catch (error) {\n    try {\n      // we retry the refresh token in case of transient error\n      // or race conditions\n      console.warn(\"error refreshing session, retrying:\", error);\n      return await _refreshSession(auth, storage, marginSeconds);\n    } catch (error) {\n      const errResponse = error as FetchResponse<ErrorResponse>;\n      if (errResponse?.status === 401) {\n        // this probably means the refresh token is invalid\n        console.error(\"session probably expired\");\n        storage.remove();\n      }\n      return null;\n    }\n  }\n};\n\n/**\n * Internal implementation of the refresh session logic\n *\n * @param auth - The authentication client to use for token refresh\n * @param storage - The session storage implementation\n * @param marginSeconds - How many seconds before expiration to trigger a refresh\n * @returns A promise that resolves to the current session (refreshed if needed) or null if no session exists\n * @private\n */\nconst _refreshSession = async (\n  auth: AuthClient,\n  storage: SessionStorage,\n  marginSeconds = 60,\n): Promise<Session | null> => {\n  const {\n    session,\n    needsRefresh,\n  }: { session: Session | null; needsRefresh: boolean } = await lock.request(\n    \"nhostSessionLock\",\n    { mode: \"shared\" },\n    async () => {\n      return _needsRefresh(storage, marginSeconds);\n    },\n  );\n\n  if (!session) {\n    return null; // No session found\n  }\n\n  if (!needsRefresh) {\n    return session; // No need to refresh\n  }\n\n  const refreshedSession: Session | null = await lock.request(\n    \"nhostSessionLock\",\n    { mode: \"exclusive\" },\n    async () => {\n      const { session, needsRefresh, sessionExpired } = _needsRefresh(\n        storage,\n        marginSeconds,\n      );\n\n      if (!session) {\n        return null; // No session found\n      }\n\n      if (!needsRefresh) {\n        return session; // No need to refresh\n      }\n\n      try {\n        const response = await auth.refreshToken({\n          refreshToken: session.refreshToken,\n        });\n        storage.set(response.body);\n\n        return response.body;\n      } catch (error) {\n        if (!sessionExpired) {\n          return session;\n        }\n\n        throw error;\n      }\n    },\n  );\n\n  return refreshedSession;\n};\n\n/**\n * Checks if the current session needs to be refreshed based on token expiration\n *\n * @param storage - The session storage implementation\n * @param marginSeconds - How many seconds before expiration to trigger a refresh\n * @returns An object containing the session, whether it needs refreshing, and whether it has expired\n * @private\n */\nconst _needsRefresh = (storage: SessionStorage, marginSeconds = 60) => {\n  const session = storage.get();\n  if (!session) {\n    return { session: null, needsRefresh: false, sessionExpired: false };\n  }\n\n  if (!session.decodedToken || !session.decodedToken.exp) {\n    // if the session does not have a valid decoded token, treat it as expired\n    // as we can't determine its validity\n    return { session, needsRefresh: true, sessionExpired: true };\n  }\n\n  // Force refresh if marginSeconds is 0\n  if (marginSeconds === 0) {\n    return { session, needsRefresh: true, sessionExpired: false };\n  }\n\n  const currentTime = Date.now();\n  if (session.decodedToken.exp - currentTime > marginSeconds * 1000) {\n    return { session, needsRefresh: false, sessionExpired: false };\n  }\n\n  return {\n    session,\n    needsRefresh: true,\n    sessionExpired: session.decodedToken.exp < currentTime,\n  };\n};\n"],"names":["error","session","needsRefresh"],"mappings":"AAKA,MAAM,UAA0B;AAAA,EAC9B,MAAM,QACJ,OACA,UAEA,UACA;AACA,WAAO,SAAA;AAAA,EACT;AACF;AAYA,MAAM,OACJ,OAAO,cAAc,eAAe,UAAU,QAC1C,UAAU,QACV,IAAI,UAAA;AAcH,MAAM,iBAAiB,OAC5B,MACA,SACA,gBAAgB,OACY;AAC5B,MAAI;AACF,WAAO,MAAM,gBAAgB,MAAM,SAAS,aAAa;AAAA,EAC3D,SAAS,OAAO;AACd,QAAI;AAGF,cAAQ,KAAK,uCAAuC,KAAK;AACzD,aAAO,MAAM,gBAAgB,MAAM,SAAS,aAAa;AAAA,IAC3D,SAASA,QAAO;AACd,YAAM,cAAcA;AACpB,UAAI,aAAa,WAAW,KAAK;AAE/B,gBAAQ,MAAM,0BAA0B;AACxC,gBAAQ,OAAA;AAAA,MACV;AACA,aAAO;AAAA,IACT;AAAA,EACF;AACF;AAWA,MAAM,kBAAkB,OACtB,MACA,SACA,gBAAgB,OACY;AAC5B,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,EAAA,IACsD,MAAM,KAAK;AAAA,IACjE;AAAA,IACA,EAAE,MAAM,SAAA;AAAA,IACR,YAAY;AACV,aAAO,cAAc,SAAS,aAAa;AAAA,IAC7C;AAAA,EAAA;AAGF,MAAI,CAAC,SAAS;AACZ,WAAO;AAAA,EACT;AAEA,MAAI,CAAC,cAAc;AACjB,WAAO;AAAA,EACT;AAEA,QAAM,mBAAmC,MAAM,KAAK;AAAA,IAClD;AAAA,IACA,EAAE,MAAM,YAAA;AAAA,IACR,YAAY;AACV,YAAM,EAAE,SAAAC,UAAS,cAAAC,eAAc,mBAAmB;AAAA,QAChD;AAAA,QACA;AAAA,MAAA;AAGF,UAAI,CAACD,UAAS;AACZ,eAAO;AAAA,MACT;AAEA,UAAI,CAACC,eAAc;AACjB,eAAOD;AAAAA,MACT;AAEA,UAAI;AACF,cAAM,WAAW,MAAM,KAAK,aAAa;AAAA,UACvC,cAAcA,SAAQ;AAAA,QAAA,CACvB;AACD,gBAAQ,IAAI,SAAS,IAAI;AAEzB,eAAO,SAAS;AAAA,MAClB,SAAS,OAAO;AACd,YAAI,CAAC,gBAAgB;AACnB,iBAAOA;AAAAA,QACT;AAEA,cAAM;AAAA,MACR;AAAA,IACF;AAAA,EAAA;AAGF,SAAO;AACT;AAUA,MAAM,gBAAgB,CAAC,SAAyB,gBAAgB,OAAO;AACrE,QAAM,UAAU,QAAQ,IAAA;AACxB,MAAI,CAAC,SAAS;AACZ,WAAO,EAAE,SAAS,MAAM,cAAc,OAAO,gBAAgB,MAAA;AAAA,EAC/D;AAEA,MAAI,CAAC,QAAQ,gBAAgB,CAAC,QAAQ,aAAa,KAAK;AAGtD,WAAO,EAAE,SAAS,cAAc,MAAM,gBAAgB,KAAA;AAAA,EACxD;AAGA,MAAI,kBAAkB,GAAG;AACvB,WAAO,EAAE,SAAS,cAAc,MAAM,gBAAgB,MAAA;AAAA,EACxD;AAEA,QAAM,cAAc,KAAK,IAAA;AACzB,MAAI,QAAQ,aAAa,MAAM,cAAc,gBAAgB,KAAM;AACjE,WAAO,EAAE,SAAS,cAAc,OAAO,gBAAgB,MAAA;AAAA,EACzD;AAEA,SAAO;AAAA,IACL;AAAA,IACA,cAAc;AAAA,IACd,gBAAgB,QAAQ,aAAa,MAAM;AAAA,EAAA;AAE/C;"}
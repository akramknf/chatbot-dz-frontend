{"version":3,"file":"fetch-DWXwEnoe.js","sources":["../src/fetch/fetch.ts"],"sourcesContent":["/**\n * Type definition for a fetch-like function.\n * Takes the same parameters as fetch and returns the same type.\n * This allows middleware to intercept and modify requests and responses.\n */\nexport type FetchFunction = (\n  url: string,\n  options?: RequestInit,\n) => Promise<Response>;\n\n/**\n * Type definition for a chain function (middleware).\n * Takes a fetch-like function and returns another fetch-like function.\n *\n * Chain functions can be used to implement:\n * - Authentication token handling\n * - Error handling and retry logic\n * - Request and response transformations\n * - Logging and metrics\n */\nexport type ChainFunction = (next: FetchFunction) => FetchFunction;\n\n/**\n * Creates an enhanced fetch function using a chain of middleware functions.\n *\n * The fetch chain executes in the order of the array, with each middleware\n * wrapping the next one in the chain. This allows each middleware to\n * intercept both the request (before calling next) and the response\n * (after calling next).\n *\n * @example\n * ```typescript\n * // Simple logging middleware\n * const loggingMiddleware: ChainFunction = (next) => {\n *   return async (url, options) => {\n *     console.log(`Request to ${url}`);\n *     const response = await next(url, options);\n *     console.log(`Response from ${url}: ${response.status}`);\n *     return response;\n *   };\n * };\n *\n * const enhancedFetch = createEnhancedFetch([loggingMiddleware]);\n * const response = await enhancedFetch('https://api.example.com/data');\n * ```\n *\n * @param chainFunctions - Array of chain functions to apply in order\n * @returns Enhanced fetch function with all middleware applied\n */\nexport function createEnhancedFetch(\n  chainFunctions: ChainFunction[] = [],\n): FetchFunction {\n  // Build the chain starting with vanilla fetch, but apply functions in reverse\n  // to achieve the desired execution order\n  return chainFunctions.reduceRight(\n    (nextInChain, chainFunction) => chainFunction(nextInChain),\n    fetch as FetchFunction,\n  );\n}\n\n/**\n * Interface representing a structured API response.\n *\n * This interface provides a consistent structure for responses across the SDK,\n * offering access to the parsed response body along with status and headers.\n *\n * @template T - The type of the response body\n */\nexport interface FetchResponse<T> {\n  /** The parsed response body */\n  body: T;\n  /** HTTP status code of the response */\n  status: number;\n  /** Response headers */\n  headers: Headers;\n}\n\nfunction extractMessage(body: unknown): string {\n  if (body && typeof body === \"string\") {\n    return body;\n  }\n\n  if (body && typeof body === \"object\") {\n    const typedBody = body as Record<string, unknown>;\n\n    if (\"message\" in typedBody && typeof typedBody[\"message\"] === \"string\") {\n      return typedBody[\"message\"];\n    }\n\n    if (\"error\" in typedBody && typeof typedBody[\"error\"] === \"string\") {\n      return typedBody[\"error\"];\n    }\n\n    if (\n      \"error\" in typedBody &&\n      typedBody[\"error\"] &&\n      typeof typedBody[\"error\"] === \"object\"\n    ) {\n      const error = typedBody[\"error\"] as Record<string, unknown>;\n      if (\"message\" in error && typeof error[\"message\"] === \"string\") {\n        return error[\"message\"];\n      }\n    }\n\n    if (\"errors\" in typedBody && Array.isArray(typedBody[\"errors\"])) {\n      const messages = (typedBody[\"errors\"] as unknown[])\n        .filter(\n          (error): error is { message: string } =>\n            typeof error === \"object\" &&\n            error !== null &&\n            \"message\" in error &&\n            typeof (error as { message: unknown })[\"message\"] === \"string\",\n        )\n        .map((error) => error[\"message\"]);\n\n      if (messages.length > 0) {\n        return messages.join(\", \");\n      }\n    }\n  }\n\n  return \"An unexpected error occurred\";\n}\n\n/**\n * Error class for representing fetch operation failures.\n *\n * This class extends the standard Error to include additional\n * information about failed requests, including the response body,\n * status code, and headers. The error message is automatically\n * extracted from common error response formats.\n *\n * @template T - The type of the response body\n */\nexport class FetchError<T = unknown> extends Error {\n  /** The original response body */\n  body: T;\n  /** HTTP status code of the failed response */\n  status: number;\n  /** Response headers */\n  headers: Headers;\n\n  /**\n   * Creates a new FetchError instance\n   *\n   * @param body - The response body from the failed request\n   * @param status - The HTTP status code\n   * @param headers - The response headers\n   */\n  constructor(body: T, status: number, headers: Headers) {\n    super(extractMessage(body));\n    this.body = body;\n    this.status = status;\n    this.headers = headers;\n  }\n}\n"],"names":["FetchError","Error","body","status","headers","constructor","super","typedBody","error","Array","isArray","messages","filter","map","length","join","extractMessage","this","chainFunctions","reduceRight","nextInChain","chainFunction","fetch"],"mappings":"aAsIO,MAAMA,UAAgCC,MAE3CC,KAEAC,OAEAC,QASA,WAAAC,CAAYH,EAASC,EAAgBC,GACnCE,MAzEJ,SAAwBJ,GACtB,GAAIA,GAAwB,iBAATA,EACjB,OAAOA,EAGT,GAAIA,GAAwB,iBAATA,EAAmB,CACpC,MAAMK,EAAYL,EAElB,GAAI,YAAaK,GAA6C,iBAAzBA,EAAmB,QACtD,OAAOA,EAAmB,QAG5B,GAAI,UAAWA,GAA2C,iBAAvBA,EAAiB,MAClD,OAAOA,EAAiB,MAG1B,GACE,UAAWA,GACXA,EAAiB,OACa,iBAAvBA,EAAiB,MACxB,CACA,MAAMC,EAAQD,EAAiB,MAC/B,GAAI,YAAaC,GAAqC,iBAArBA,EAAe,QAC9C,OAAOA,EAAe,OAE1B,CAEA,GAAI,WAAYD,GAAaE,MAAMC,QAAQH,EAAkB,QAAI,CAC/D,MAAMI,EAAYJ,EAAkB,OACjCK,QACEJ,GACkB,iBAAVA,GACG,OAAVA,GACA,YAAaA,GACyC,iBAA9CA,EAAwC,UAEnDK,KAAKL,GAAUA,EAAe,UAEjC,GAAIG,EAASG,OAAS,EACpB,OAAOH,EAASI,KAAK,KAEzB,CACF,CAEA,MAAO,8BACT,CA4BUC,CAAed,IACrBe,KAAKf,KAAOA,EACZe,KAAKd,OAASA,EACdc,KAAKb,QAAUA,CACjB,mDAzGK,SACLc,EAAkC,IAIlC,OAAOA,EAAeC,aACpB,CAACC,EAAaC,IAAkBA,EAAcD,IAC9CE,MAEJ"}